<body style="padding:0;margin:0" >


<canvas id="screen" style="border:0;margin:0;" />
<canvas id="game" style="display:none;" />

<script> // function definitions
function isomorphicContext(){
  var rootTilePosition = [235, 230];
  //var rootTileGrid = [258, 252];
  var mouseoverTile = [2, 3];
  var selectedTile = [4, 8];
  var Tiles = [
    ["GreenTile", "GreenTile", "GreenTile", "GreenTile", "GreenTile", "GreenTile", "GreenTile", "GreenTile", "GreenTile", "GreenTile"],
    ["GreenTile", "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GreenTile"],
    ["GreenTile", "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GreenTile"],
    ["GreenTile", "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GreenTile"],
    ["GreenTile", "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GreenTile"],
    ["GreenTile", "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GreenTile"],
    ["GreenTile", "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GreenTile"],
    ["GreenTile", "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GreenTile"],
    ["GreenTile", "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GrayTile" , "GreenTile"],
    ["GreenTile", "GreenTile", "GreenTile", "GreenTile", "GreenTile", "GreenTile", "GreenTile", "GreenTile", "GreenTile", "GreenTile"],
  ];
  function gameCoordsToTile (x, y) {
    //return [Math.floor(Math.random()*10), Math.floor(Math.random()*10)];
    // magic numbers:
    // 8634 = rootTileGrid[0]*11 + rootTileGrid[1]*23
    // 3204 = - rootTileGrid[0]*12 + rootTileGrid[1]*25
    // 551 = 25*11 + 23*12;
    let xx = (3204 - 25*y + 12*x)/551;
    let yy = (8634 - 23*y - 11*x)/551;
    // detect the lower edges of tiles on edge of grid
    if (xx < 0 && xx > -0.5) {
      xx = 0;
      yy = (258 - x)/25;
    }
    if (yy < 0 && yy > -0.5) {
      yy = 0
      xx = (x - 258)/23;
    }
    return [Math.floor(xx), Math.floor(yy)];
  }
  return {
    gameClick : function (x, y) {
      // handle a click within the game
      // check the current tile using x, y
      selectedTile = gameCoordsToTile (x, y);

      // mark selected tile with red border (done in draw)

      // update to display the change (call here or set flag)
      screenDirty = true;
    },
    gameMousemove : function (x, y) {
      // handle a click within the game
      // check the current tile using x, y
      mouseoverTile = gameCoordsToTile (x, y);

      // highlight the selected tile (done in draw)

      // update to display the change (call here or set flag)
      screenDirty = true;
    },
    gameKeydown : function (key) {
      // key: keycode of event key
      // console.log(key);
    },
    gameLoad : function () {
      // What to do when loading this context
      screenDirty = true;
    },
    gameDraw : function () {
      // What to do when drawing a dirty screen, every time
      gameDraw.fillStyle = "#0000FF";
      gameDraw.fillRect(0, 0, gameSize[0], gameSize[1]);
      for (let i = 9; i >= 0; i--) {
        for (let j = 9; j >= 0; j--) {
          gameDraw.drawImage(Images[Tiles[i][j]], rootTilePosition[0]+i*23-j*25, rootTilePosition[1]-i*11-j*12);
          if (selectedTile && selectedTile[0]==i && selectedTile[1] == j) {
            gameDraw.drawImage(Images.RedSelect, rootTilePosition[0]+i*23-j*25, rootTilePosition[1]-i*11-j*12);
            gameDraw.drawImage(Images.YellowSelect, rootTilePosition[0]+i*23-j*25, rootTilePosition[1]-i*11-j*12);
          }
          else if (mouseoverTile && mouseoverTile[0]==i && mouseoverTile[1] == j) {
            gameDraw.drawImage(Images.YellowSelect, rootTilePosition[0]+i*23-j*25, rootTilePosition[1]-i*11-j*12);
          }
        }
      }
    }
  };
}
function loadImages(){
  return {
    // make :b:artin
    GreenTile: addImage("images/green1.png", "greenTile"),
    GrayTile: addImage("images/gray1.png", "grayTile"),
    RedSelect: addImage("images/redselect.png", "redSelect"),
    YellowSelect: addImage("images/yellowselect.png", "yellowSelect"),
  };
}
function initGame(){ // use images in here
  screenDraw.fillStyle = bgColor;
  screenDraw.fillRect(0, 0, screenSize[0], screenSize[1]);
  eventContext.gameLoad();
  updateScreen();
}
function addImage(imageLocation, imageName){
  // create and return reference to new image element
  // location is used as source of image
  // name will become ID of image element
  var ret = document.createElement("img");
  ret.src = imageLocation;
  ret.id = imageName; // maybe add image prefix
  ret.style = "display:none;";
  document.body.appendChild(ret); // should not display; test if this is necessary; maybe set to game home rather than document
  return ret; // todo: test that this loads correctly
}
function updateScreen() {
  if (screenDirty) {
    eventContext.gameDraw();
    screenDraw.drawImage(gameCanvas, screenAspectOrigin[0], screenAspectOrigin[1], screenAspectSize[0], screenAspectSize[1]);
    screenDirty = false;
  }
}
function handleClick(e){
  // convert window coordinates to game coordinates
  var xx = Math.trunc((e.clientX - screenAspectOrigin[0])*screenScale);
  var yy = Math.trunc((e.clientY - screenAspectOrigin[1])*screenScale);
  if (xx < 0 || xx > gameSize[0]) return;
  if (yy < 0 || yy > gameSize[1]) return;
  // hook event from event context
  eventContext.gameClick(xx, yy);
  updateScreen();
}
function handleMousemove(e){
  // convert window coordinates to game coordinates
  var xx = Math.trunc((e.clientX - screenAspectOrigin[0])*screenScale);
  var yy = Math.trunc((e.clientY - screenAspectOrigin[1])*screenScale);
  if (xx < 0 || xx > gameSize[0]) return;
  if (yy < 0 || yy > gameSize[1]) return;
  // hook event from event context (maybe merge this with event handler)
  eventContext.gameMousemove(xx, yy);
  updateScreen();
}
function handleKeydown(e){
  // hook event from event context (maybe merge this with event handler)
  eventContext.gameKeydown(e.keyCode);
  updateScreen();
}
</script>

<script> // globals and entry points
//var screen = document.getElementById("screen")
var defaultColor = "#000000";
var bgColor = "#aaaaaa";

// initialize window
var gameCanvas = document.getElementById("game");
var gameSize = [500, 300];
gameCanvas.width = gameSize[0];
gameCanvas.height = gameSize[1];
var gameDraw = gameCanvas.getContext("2d");
gameDraw.imageSmoothingEnabled = false;

// resize main canvas to iframe/window size
var screenCanvas = document.getElementById("screen");
var screenSize = [window.innerWidth, window.innerHeight];
screenCanvas.width = screenSize[0];
screenCanvas.height = screenSize[1];

// calculate aspect ratio and origin to draw game canvas onto main canvas
var aspectRatio = gameSize[0]/gameSize[1];
var screenAspectOrigin = [0, 0];
var screenAspectSize = [screenSize[0], screenSize[1]];
var screenScale;
if (aspectRatio > (screenSize[0]/screenSize[1])) {
  screenAspectSize[1] = screenSize[0]/aspectRatio;
  screenAspectOrigin[1] = (screenSize[1]-screenAspectSize[1])/2;
  screenScale = gameSize[0]/screenAspectSize[0];
} else {
  screenAspectSize[0] = screenSize[1]*aspectRatio;
  screenAspectOrigin[0] = (screenSize[0]-screenAspectSize[0])/2;
  screenScale = gameSize[1]/screenAspectSize[1];
}

// get main context; drawn from game canvas
var screenDraw = screenCanvas.getContext("2d");
screenDraw.imageSmoothingEnabled = false;
var screenDirty = false;

eventContext = isomorphicContext();
Images = loadImages();
//tileSize = [47, 35];

// add event listeners with hooks for game object
window.addEventListener("click", handleClick);
window.addEventListener("mousemove", handleMousemove);
window.addEventListener("keydown", handleKeydown);
// add load listener to wait for code-generated elements and assets, i.e. loadImages()
window.addEventListener("load", initGame);
</script>
</body>